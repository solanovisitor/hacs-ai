"""HACS Health Checks and Performance Monitoring.

This module provideshealth check and performance monitoring
capabilities for healthcare AI systems with proactive issue detection.

Features:
    - System health monitoring
    - Performance benchmarking
    - Resource utilization tracking
    - Service dependency health checks
    - Healthcare-specific health metrics
    - Proactive issue detection
    - Health check reporting and dashboards

Author: HACS Development Team
License: MIT
Version: 1.0.0
"""

import asyncio
import contextlib
import socket
import time
from collections.abc import Callable
from dataclasses import dataclass, field
from datetime import UTC, datetime
from enum import Enum
from typing import Any

import psutil

from .monitoring import HealthCheckResult
from .observability import get_observability_manager


class HealthStatus(str, Enum):
    """Health check status."""

    HEALTHY = "healthy"
    DEGRADED = "degraded"
    UNHEALTHY = "unhealthy"
    UNKNOWN = "unknown"


class CheckType(str, Enum):
    """Types of health checks."""

    SYSTEM = "system"
    DATABASE = "database"
    NETWORK = "network"
    SERVICE = "service"
    HEALTHCARE = "healthcare"
    SECURITY = "security"
    PERFORMANCE = "performance"


@dataclass
class HealthCheckConfig:
    """Health check configuration."""

    name: str
    check_type: CheckType
    description: str
    enabled: bool = True
    interval_seconds: int = 30
    timeout_seconds: int = 10
    failure_threshold: int = 3
    success_threshold: int = 2
    tags: list[str] = field(default_factory=list)
    dependencies: list[str] = field(default_factory=list)


@dataclass
class HealthMetric:
    """Health metric data point."""

    name: str
    value: float
    unit: str
    status: HealthStatus
    timestamp: datetime
    threshold_warning: float | None = None
    threshold_critical: float | None = None
    tags: dict[str, str] = field(default_factory=dict)


@dataclass
class HealthReport:
    """Comprehensive health report."""

    timestamp: datetime
    overall_status: HealthStatus
    service_name: str
    version: str
    uptime_seconds: float
    checks: dict[str, HealthCheckResult]
    metrics: dict[str, HealthMetric]
    dependencies: dict[str, HealthStatus]
    alerts: list[str] = field(default_factory=list)
    recommendations: list[str] = field(default_factory=list)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "timestamp": self.timestamp.isoformat(),
            "overall_status": self.overall_status.value,
            "service_name": self.service_name,
            "version": self.version,
            "uptime_seconds": self.uptime_seconds,
            "uptime_human": self._format_uptime(self.uptime_seconds),
            "checks": {
                name: {
                    "status": result.is_healthy,
                    "response_time_ms": result.response_time,
                    "error": result.error,
                    "details": result.details,
                    "timestamp": datetime.fromtimestamp(
                        result.timestamp, tz=UTC
                    ).isoformat(),
                }
                for name, result in self.checks.items()
            },
            "metrics": {
                name: {
                    "value": metric.value,
                    "unit": metric.unit,
                    "status": metric.status.value,
                    "timestamp": metric.timestamp.isoformat(),
                    "thresholds": {
                        "warning": metric.threshold_warning,
                        "critical": metric.threshold_critical,
                    },
                    "tags": metric.tags,
                }
                for name, metric in self.metrics.items()
            },
            "dependencies": {name: status.value for name, status in self.dependencies.items()},
            "alerts": self.alerts,
            "recommendations": self.recommendations,
        }

    def _format_uptime(self, seconds: float) -> str:
        """Format uptime in human readable form."""
        days = int(seconds // 86400)
        hours = int((seconds % 86400) // 3600)
        minutes = int((seconds % 3600) // 60)

        if days > 0:
            return f"{days}d {hours}h {minutes}m"
        if hours > 0:
            return f"{hours}h {minutes}m"
        return f"{minutes}m"


class HealthCheckManager:
    """Comprehensive health check manager."""

    def __init__(self, service_name: str = "hacs-healthcare-ai", version: str = "1.0.0") -> None:
        """Initialize health check manager."""
        self.service_name = service_name
        self.version = version
        self.start_time = time.time()

        self.observability = get_observability_manager()
        self.logger = self.observability.get_logger("hacs.health_checks")

        # Health check configurations
        self._check_configs: dict[str, HealthCheckConfig] = {}
        self._check_functions: dict[str, Callable[[], bool | dict[str, Any]]] = {}

        # Health state
        self._check_results: dict[str, HealthCheckResult] = {}
        self._check_history: dict[str, list[bool]] = {}
        self._metrics: dict[str, HealthMetric] = {}

        # Background monitoring
        self._running = False
        self._monitoring_task: asyncio.Task | None = None

        # Initialize default health checks
        self._setup_default_checks()

    def _setup_default_checks(self) -> None:
        """Setup default system health checks."""
        # System resource checks
        self.register_health_check(
            HealthCheckConfig(
                name="system_cpu",
                check_type=CheckType.SYSTEM,
                description="CPU usage monitoring",
                interval_seconds=30,
                tags=["system", "cpu"],
            ),
            self._check_cpu_usage,
        )

        self.register_health_check(
            HealthCheckConfig(
                name="system_memory",
                check_type=CheckType.SYSTEM,
                description="Memory usage monitoring",
                interval_seconds=30,
                tags=["system", "memory"],
            ),
            self._check_memory_usage,
        )

        self.register_health_check(
            HealthCheckConfig(
                name="system_disk",
                check_type=CheckType.SYSTEM,
                description="Disk usage monitoring",
                interval_seconds=60,
                tags=["system", "disk"],
            ),
            self._check_disk_usage,
        )

        # Network connectivity checks
        self.register_health_check(
            HealthCheckConfig(
                name="network_connectivity",
                check_type=CheckType.NETWORK,
                description="Network connectivity check",
                interval_seconds=60,
                tags=["network", "connectivity"],
            ),
            self._check_network_connectivity,
        )

        # Healthcare-specific checks
        self.register_health_check(
            HealthCheckConfig(
                name="phi_encryption",
                check_type=CheckType.HEALTHCARE,
                description="PHI encryption status",
                interval_seconds=300,  # 5 minutes
                tags=["healthcare", "phi", "encryption"],
            ),
            self._check_phi_encryption,
        )

        self.register_health_check(
            HealthCheckConfig(
                name="hipaa_compliance",
                check_type=CheckType.HEALTHCARE,
                description="HIPAA compliance status",
                interval_seconds=300,  # 5 minutes
                tags=["healthcare", "hipaa", "compliance"],
            ),
            self._check_hipaa_compliance,
        )

        # Security checks
        self.register_health_check(
            HealthCheckConfig(
                name="auth_service",
                check_type=CheckType.SECURITY,
                description="Authentication service health",
                interval_seconds=60,
                tags=["security", "authentication"],
            ),
            self._check_auth_service,
        )

        # Performance checks
        self.register_health_check(
            HealthCheckConfig(
                name="response_time",
                check_type=CheckType.PERFORMANCE,
                description="Average response time monitoring",
                interval_seconds=30,
                tags=["performance", "response_time"],
            ),
            self._check_response_time,
        )

    def register_health_check(
        self, config: HealthCheckConfig, check_function: Callable[[], bool | dict[str, Any]]
    ) -> None:
        """Register a health check."""
        self._check_configs[config.name] = config
        self._check_functions[config.name] = check_function
        self._check_history[config.name] = []

        self.logger.info(f"Registered health check: {config.name}")

    async def start(self) -> None:
        """Start health monitoring."""
        if self._running:
            return

        self._running = True
        self._monitoring_task = asyncio.create_task(self._monitoring_loop())

        self.logger.info("Health check monitoring started")

    async def stop(self) -> None:
        """Stop health monitoring."""
        if not self._running:
            return

        self._running = False

        if self._monitoring_task:
            self._monitoring_task.cancel()
            with contextlib.suppress(asyncio.CancelledError):
                await self._monitoring_task

        self.logger.info("Health check monitoring stopped")

    async def run_all_checks(self) -> dict[str, HealthCheckResult]:
        """Run all enabled health checks."""
        results = {}

        for name, config in self._check_configs.items():
            if not config.enabled:
                continue

            try:
                result = await self._run_single_check(name)
                results[name] = result
            except Exception as e:
                self.logger.exception(f"Error running health check {name}: {e}")
                results[name] = HealthCheckResult(
                    service_name=name, is_healthy=False, response_time=0, error=str(e)
                )

        return results

    async def run_check(self, check_name: str) -> HealthCheckResult | None:
        """Run a specific health check."""
        if check_name not in self._check_configs:
            return None

        try:
            return await self._run_single_check(check_name)
        except Exception as e:
            self.logger.exception(f"Error running health check {check_name}: {e}")
            return HealthCheckResult(
                service_name=check_name, is_healthy=False, response_time=0, error=str(e)
            )

    async def get_health_report(self) -> HealthReport:
        """Gethealth report."""
        # Run all checks
        check_results = await self.run_all_checks()

        # Update metrics
        await self._update_system_metrics()

        # Determine overall status
        overall_status = self._determine_overall_status(check_results)

        # Generate alerts and recommendations
        alerts = self._generate_alerts(check_results)
        recommendations = self._generate_recommendations(check_results)

        # Get dependency status
        dependencies = self._get_dependency_status()

        return HealthReport(
            timestamp=datetime.now(UTC),
            overall_status=overall_status,
            service_name=self.service_name,
            version=self.version,
            uptime_seconds=time.time() - self.start_time,
            checks=check_results,
            metrics=self._metrics.copy(),
            dependencies=dependencies,
            alerts=alerts,
            recommendations=recommendations,
        )

    async def _monitoring_loop(self) -> None:
        """Background health monitoring loop."""
        check_schedules = dict.fromkeys(self._check_configs.keys(), 0)

        while self._running:
            try:
                current_time = time.time()

                # Check which health checks need to run
                for name, config in self._check_configs.items():
                    if not config.enabled:
                        continue

                    if current_time >= check_schedules[name]:
                        # Schedule next run
                        check_schedules[name] = current_time + config.interval_seconds

                        # Run check asynchronously
                        asyncio.create_task(self._run_and_store_check(name))

                # Update system metrics
                await self._update_system_metrics()

                await asyncio.sleep(5)  # Check schedule every 5 seconds

            except asyncio.CancelledError:
                break
            except Exception as e:
                self.logger.exception(f"Error in monitoring loop: {e}")
                await asyncio.sleep(30)

    async def _run_and_store_check(self, check_name: str) -> None:
        """Run a health check and store the result."""
        try:
            result = await self._run_single_check(check_name)
            self._check_results[check_name] = result

            # Update check history
            history = self._check_history[check_name]
            history.append(result.is_healthy)

            # Keep only recent history
            if len(history) > 100:
                history[:] = history[-100:]

        except Exception as e:
            self.logger.exception(f"Error running health check {check_name}: {e}")

    async def _run_single_check(self, check_name: str) -> HealthCheckResult:
        """Run a single health check."""
        config = self._check_configs[check_name]
        check_function = self._check_functions[check_name]

        start_time = time.time()

        try:
            # Run check with timeout
            result = await asyncio.wait_for(
                self._execute_check_function(check_function), timeout=config.timeout_seconds
            )

            response_time = (time.time() - start_time) * 1000  # Convert to ms

            if isinstance(result, bool):
                return HealthCheckResult(
                    service_name=check_name, is_healthy=result, response_time=response_time
                )
            if isinstance(result, dict):
                return HealthCheckResult(
                    service_name=check_name,
                    is_healthy=result.get("healthy", False),
                    response_time=response_time,
                    details=result.get("details", {}),
                    error=result.get("error"),
                )
            return HealthCheckResult(
                service_name=check_name,
                is_healthy=False,
                response_time=response_time,
                error="Invalid check function return type",
            )

        except TimeoutError:
            response_time = (time.time() - start_time) * 1000
            return HealthCheckResult(
                service_name=check_name,
                is_healthy=False,
                response_time=response_time,
                error=f"Check timed out after {config.timeout_seconds} seconds",
            )
        except Exception as e:
            response_time = (time.time() - start_time) * 1000
            return HealthCheckResult(
                service_name=check_name, is_healthy=False, response_time=response_time, error=str(e)
            )

    async def _execute_check_function(self, check_function: Callable):
        """Execute a check function (sync or async)."""
        if asyncio.iscoroutinefunction(check_function):
            return await check_function()
        # Run sync function in thread pool
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(None, check_function)

    async def _update_system_metrics(self) -> None:
        """Update system performance metrics."""
        try:
            now = datetime.now(UTC)

            # CPU metrics
            cpu_percent = psutil.cpu_percent(interval=None)
            self._metrics["cpu_usage"] = HealthMetric(
                name="cpu_usage",
                value=cpu_percent,
                unit="percent",
                status=self._get_metric_status(cpu_percent, 70, 90),
                timestamp=now,
                threshold_warning=70,
                threshold_critical=90,
                tags={"category": "system"},
            )

            # Memory metrics
            memory = psutil.virtual_memory()
            self._metrics["memory_usage"] = HealthMetric(
                name="memory_usage",
                value=memory.percent,
                unit="percent",
                status=self._get_metric_status(memory.percent, 80, 95),
                timestamp=now,
                threshold_warning=80,
                threshold_critical=95,
                tags={"category": "system"},
            )

            # Disk metrics
            disk = psutil.disk_usage("/")
            disk_percent = (disk.used / disk.total) * 100
            self._metrics["disk_usage"] = HealthMetric(
                name="disk_usage",
                value=disk_percent,
                unit="percent",
                status=self._get_metric_status(disk_percent, 80, 95),
                timestamp=now,
                threshold_warning=80,
                threshold_critical=95,
                tags={"category": "system"},
            )

            # Network metrics (simplified)
            network = psutil.net_io_counters()
            self._metrics["network_bytes_sent"] = HealthMetric(
                name="network_bytes_sent",
                value=network.bytes_sent / (1024 * 1024),  # MB
                unit="MB",
                status=HealthStatus.HEALTHY,
                timestamp=now,
                tags={"category": "network"},
            )

        except Exception as e:
            self.logger.exception(f"Error updating system metrics: {e}")

    def _get_metric_status(
        self, value: float, warning_threshold: float, critical_threshold: float
    ) -> HealthStatus:
        """Determine metric status based on thresholds."""
        if value >= critical_threshold:
            return HealthStatus.UNHEALTHY
        if value >= warning_threshold:
            return HealthStatus.DEGRADED
        return HealthStatus.HEALTHY

    def _determine_overall_status(
        self, check_results: dict[str, HealthCheckResult]
    ) -> HealthStatus:
        """Determine overall system health status."""
        if not check_results:
            return HealthStatus.UNKNOWN

        healthy_count = sum(1 for result in check_results.values() if result.is_healthy)
        total_count = len(check_results)
        health_ratio = healthy_count / total_count

        if health_ratio == 1.0:
            return HealthStatus.HEALTHY
        if health_ratio >= 0.8:
            return HealthStatus.DEGRADED
        return HealthStatus.UNHEALTHY

    def _generate_alerts(self, check_results: dict[str, HealthCheckResult]) -> list[str]:
        """Generate alerts based on check results."""
        alerts = []

        for name, result in check_results.items():
            if not result.is_healthy:
                config = self._check_configs.get(name)
                if config:
                    if config.check_type == CheckType.HEALTHCARE:
                        alerts.append(f"HEALTHCARE ALERT: {config.description} is failing")
                    elif config.check_type == CheckType.SECURITY:
                        alerts.append(f"SECURITY ALERT: {config.description} is failing")
                    else:
                        alerts.append(f"SYSTEM ALERT: {config.description} is failing")

        # Check system metrics
        for name, metric in self._metrics.items():
            if metric.status == HealthStatus.UNHEALTHY:
                alerts.append(f"CRITICAL: {name} is at {metric.value:.1f}{metric.unit}")
            elif metric.status == HealthStatus.DEGRADED:
                alerts.append(f"WARNING: {name} is at {metric.value:.1f}{metric.unit}")

        return alerts

    def _generate_recommendations(self, check_results: dict[str, HealthCheckResult]) -> list[str]:
        """Generate recommendations based on check results."""
        recommendations = []

        # System resource recommendations
        cpu_metric = self._metrics.get("cpu_usage")
        if cpu_metric and cpu_metric.status != HealthStatus.HEALTHY:
            recommendations.append(
                "Consider scaling up CPU resources or optimizing CPU-intensive processes"
            )

        memory_metric = self._metrics.get("memory_usage")
        if memory_metric and memory_metric.status != HealthStatus.HEALTHY:
            recommendations.append(
                "Consider increasing memory allocation or optimizing memory usage"
            )

        disk_metric = self._metrics.get("disk_usage")
        if disk_metric and disk_metric.status != HealthStatus.HEALTHY:
            recommendations.append("Consider cleaning up disk space or expanding storage capacity")

        # Healthcare-specific recommendations
        for name, result in check_results.items():
            if not result.is_healthy:
                config = self._check_configs.get(name)
                if config and config.check_type == CheckType.HEALTHCARE:
                    recommendations.append(
                        f"Review and resolve healthcare compliance issue: {name}"
                    )

        return recommendations

    def _get_dependency_status(self) -> dict[str, HealthStatus]:
        """Get status of service dependencies."""
        # This would typically check external services
        # For now, return mock data
        return {
            "database": HealthStatus.HEALTHY,
            "auth_service": HealthStatus.HEALTHY,
            "external_apis": HealthStatus.HEALTHY,
        }

    # Default health check implementations
    def _check_cpu_usage(self) -> dict[str, Any]:
        """Check CPU usage."""
        cpu_percent = psutil.cpu_percent(interval=1)
        return {
            "healthy": cpu_percent < 90,
            "details": {"cpu_usage_percent": cpu_percent},
            "error": f"High CPU usage: {cpu_percent:.1f}%" if cpu_percent >= 90 else None,
        }

    def _check_memory_usage(self) -> dict[str, Any]:
        """Check memory usage."""
        memory = psutil.virtual_memory()
        return {
            "healthy": memory.percent < 95,
            "details": {
                "memory_usage_percent": memory.percent,
                "available_mb": memory.available / (1024 * 1024),
            },
            "error": f"High memory usage: {memory.percent:.1f}%" if memory.percent >= 95 else None,
        }

    def _check_disk_usage(self) -> dict[str, Any]:
        """Check disk usage."""
        disk = psutil.disk_usage("/")
        disk_percent = (disk.used / disk.total) * 100
        return {
            "healthy": disk_percent < 95,
            "details": {
                "disk_usage_percent": disk_percent,
                "free_gb": disk.free / (1024 * 1024 * 1024),
            },
            "error": f"High disk usage: {disk_percent:.1f}%" if disk_percent >= 95 else None,
        }

    def _check_network_connectivity(self) -> dict[str, Any]:
        """Check network connectivity."""
        try:
            # Try to connect to a reliable host
            socket.create_connection(("8.8.8.8", 53), timeout=5)
            return {"healthy": True, "details": {"connectivity": "ok"}}
        except Exception as e:
            return {
                "healthy": False,
                "details": {"connectivity": "failed"},
                "error": f"Network connectivity failed: {e!s}",
            }

    def _check_phi_encryption(self) -> dict[str, Any]:
        """Check PHI encryption status."""
        # This would check if PHI encryption is properly configured
        # For now, return healthy status
        return {
            "healthy": True,
            "details": {"encryption_enabled": True, "algorithm": "AES-256-GCM"},
        }

    def _check_hipaa_compliance(self) -> dict[str, Any]:
        """Check HIPAA compliance status."""
        # This would run compliance checks
        # For now, return healthy status
        return {"healthy": True, "details": {"compliance_score": 95, "violations": 0}}

    def _check_auth_service(self) -> dict[str, Any]:
        """Check authentication service health."""
        # This would check if the auth service is responding
        # For now, return healthy status
        return {"healthy": True, "details": {"service_status": "running", "response_time_ms": 150}}

    def _check_response_time(self) -> dict[str, Any]:
        """Check average response time."""
        # This would check actual response times from metrics
        # For now, return mock data
        avg_response_time = 250  # Mock value
        return {
            "healthy": avg_response_time < 1000,
            "details": {"avg_response_time_ms": avg_response_time},
            "error": f"High response time: {avg_response_time}ms"
            if avg_response_time >= 1000
            else None,
        }


# Global health check manager
_health_check_manager: HealthCheckManager | None = None


def get_health_check_manager() -> HealthCheckManager:
    """Get or create global health check manager."""
    global _health_check_manager
    if _health_check_manager is None:
        _health_check_manager = HealthCheckManager()
    return _health_check_manager


def initialize_health_checks(
    service_name: str = "hacs-healthcare-ai", version: str = "1.0.0"
) -> HealthCheckManager:
    """Initialize health check system."""
    global _health_check_manager
    _health_check_manager = HealthCheckManager(service_name, version)
    return _health_check_manager


# Export public API
__all__ = [
    "CheckType",
    "HealthCheckConfig",
    "HealthCheckManager",
    "HealthMetric",
    "HealthReport",
    "HealthStatus",
    "get_health_check_manager",
    "initialize_health_checks",
]
